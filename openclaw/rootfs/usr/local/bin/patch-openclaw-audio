#!/bin/bash
# Patch OpenClaw to filter out raw audio files from model context
# This prevents Claude from using native audio support after local transcription
# See: https://github.com/openclaw/openclaw/issues/4197

APPLY_JS="/usr/lib/node_modules/openclaw/dist/media-understanding/apply.js"

if [[ ! -f "$APPLY_JS" ]]; then
    echo "Error: apply.js not found at $APPLY_JS" >&2
    exit 1
fi

# Check if already patched with v3
if grep -q "PATCH_V3_AUDIO_FILTER" "$APPLY_JS"; then
    echo "OpenClaw audio patch v3 already applied"
    exit 0
fi

# Create backup
cp "$APPLY_JS" "$APPLY_JS.bak"

# Create a Node.js script to properly patch the file
node << 'NODEJS_PATCH'
const fs = require('fs');
const path = '/usr/lib/node_modules/openclaw/dist/media-understanding/apply.js';

let code = fs.readFileSync(path, 'utf8');

// Add the audio filter helper at the top of the file
const audioFilterCode = `
// PATCH_V3_AUDIO_FILTER: Skip audio files from model context and clear MediaPath after transcription
const _audioExtsToFilter = new Set(['.ogg', '.opus', '.mp3', '.wav', '.aac', '.flac', '.m4a', '.oga', '.webm', '.amr', '.3gp']);
function _shouldFilterAudioFile(filePath) {
    if (!filePath) return false;
    const ext = '.' + String(filePath).toLowerCase().split('.').pop();
    return _audioExtsToFilter.has(ext);
}
function _clearAudioMediaFields(ctx) {
    // Clear media fields to prevent native audio processing by Claude
    // Similar to how Telegram handles this in bot-message-dispatch.js
    ctx.MediaPath = undefined;
    ctx.MediaUrl = undefined;
    ctx.MediaType = undefined;
    ctx.MediaPaths = undefined;
    ctx.MediaUrls = undefined;
    ctx.MediaTypes = undefined;
}
`;

// Insert at the beginning after imports
const importMatch = code.match(/^(import .+\n)+/m);
if (importMatch) {
    const insertPos = importMatch.index + importMatch[0].length;
    code = code.slice(0, insertPos) + audioFilterCode + code.slice(insertPos);
}

// Patch 1: Filter audio files in extractFileBlocks
code = code.replace(
    /(const nameHint = bufferResult\?\.fileName \?\? attachment\.path \?\? attachment\.url;)/g,
    `$1
        // PATCH: Skip audio files unconditionally
        if (_shouldFilterAudioFile(nameHint)) {
            logVerbose?.(\`media: file attachment skipped (audio filter) path=\${nameHint}\`);
            continue;
        }`
);

// Patch 2: Clear MediaPath after successful audio transcription
// Find: if (audioOutputs.length > 0) {
//           const transcript = formatAudioTranscripts(audioOutputs);
//           ctx.Transcript = transcript;
// Add after ctx.Transcript = transcript: _clearAudioMediaFields(ctx);
code = code.replace(
    /(if \(audioOutputs\.length > 0\) \{\s*const transcript = formatAudioTranscripts\(audioOutputs\);\s*ctx\.Transcript = transcript;)/g,
    `$1
                // PATCH: Clear media fields to prevent native audio processing
                _clearAudioMediaFields(ctx);
                logVerbose?.("media: cleared audio MediaPath/MediaUrl after transcription");`
);

fs.writeFileSync(path, code);
console.log('OpenClaw audio patch v3 applied successfully');

// Verify patches were applied
const patched = fs.readFileSync(path, 'utf8');
const hasFilter = patched.includes('_shouldFilterAudioFile(nameHint)');
const hasClear = patched.includes('_clearAudioMediaFields(ctx)');
if (hasFilter && hasClear) {
    console.log('Verification: Both patches applied correctly');
} else {
    console.error('Verification FAILED: filter=' + hasFilter + ' clear=' + hasClear);
    process.exit(1);
}
NODEJS_PATCH

echo "Patch complete"
